# app.py

from tkinter import _test
from sklearn.metrics import mean_squared_error, r2_score
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.model_selection import train_test_split

st.set_page_config(page_title="Solar Power EDA Dashboard", layout="wide")
st.title("‚ö° Solar Power Exploratory Data Analysis (EDA)")
st.markdown("This dashboard provides visual insights into the performance of solar clusters based on uploaded Excel data.")

st.sidebar.header("üìÇ Upload Excel File")
uploaded_file = st.sidebar.file_uploader("Upload your Excel file", type=["xlsx", "xls"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)
    
    # Ensure correct column name
    if "total_powe" in df.columns:
        df.rename(columns={"total_powe": "total_power_kw"}, inplace=True)

    st.success("‚úÖ File uploaded successfully!")
    st.dataframe(df.head())

    # -------------------- EDA Section --------------------
    # 1. Irradiance vs Total Power
    st.subheader("‚òÄÔ∏è Irradiance vs Total Power")
    st.markdown("_This chart shows how the power output increases with irradiance across all clusters._")
    fig1, ax1 = plt.subplots(figsize=(10, 6))
    sns.scatterplot(data=df, x="irradiance", y="total_power_kw", alpha=0.3, ax=ax1)
    ax1.set_title("Irradiance vs Total Power (All Clusters)")
    ax1.set_xlabel("Irradiance (W/m¬≤)")
    ax1.set_ylabel("Total Power (kW)")
    ax1.grid(True)
    st.pyplot(fig1)
    

    # 2. Average Power per Cluster
    st.subheader("üìä Average Total Power per Cluster")
    st.markdown("_This bar chart displays the average total power generated by each cluster._")
    avg_power_cluster = df.groupby("cluster")["total_power_kw"].mean().sort_values()
    fig2, ax2 = plt.subplots(figsize=(10, 6))
    avg_power_cluster.plot(kind="barh", color='skyblue', ax=ax2)
    ax2.set_title("Average Total Power per Cluster")
    ax2.set_xlabel("Average Power (kW)")
    ax2.set_ylabel("Cluster")
    ax2.grid(True)
    st.pyplot(fig2)
    

    # 3. Total Energy Per Day
    st.subheader("üìà Total Energy Production per Day")
    st.markdown("_This line plot shows the total energy produced each day._")
    daily_total = df.groupby("day")["total_power_kw"].sum()
    fig3, ax3 = plt.subplots(figsize=(12, 5))
    daily_total.plot(marker='o', linestyle='-', ax=ax3)
    ax3.set_title("Total Energy Production per Day (All Clusters)")
    ax3.set_xlabel("Day")
    ax3.set_ylabel("Total Power (kW)")
    ax3.grid(True)
    plt.xticks(rotation=45)
    st.pyplot(fig3)
    

    # 4. Irradiance Distribution
    st.subheader("üìâ Distribution of Irradiance Values")
    st.markdown("_This histogram displays how frequently different irradiance values occur._")
    fig4, ax4 = plt.subplots(figsize=(10, 5))
    ax4.hist(df["irradiance"], bins=50, color="orange", edgecolor="black", alpha=0.7)
    ax4.set_title("Distribution of Irradiance Values")
    ax4.set_xlabel("Irradiance (W/m¬≤)")
    ax4.set_ylabel("Frequency")
    ax4.grid(True)
    st.pyplot(fig4)
    

    # 5. Power Distribution per Cluster
    st.subheader("üì¶ Power Output Distribution per Cluster")
    st.markdown("_This boxplot reveals how power values are distributed in each cluster, including variability and outliers._")
    fig5, ax5 = plt.subplots(figsize=(14, 6))
    sns.boxplot(data=df, x="cluster", y="total_power_kw", palette="coolwarm", ax=ax5)
    ax5.set_title("Power Output Distribution per Cluster")
    ax5.set_xlabel("Cluster")
    ax5.set_ylabel("Total Power (kW)")
    ax5.tick_params(axis='x', rotation=45)
    st.pyplot(fig5)
    

    # 6. Efficiency Ratio (Power / Irradiance)
    st.subheader("‚öôÔ∏è Power Efficiency Ratio per Cluster")
    st.markdown("_This boxplot shows the efficiency of clusters in converting irradiance into power output._")
    df_eff = df[df['irradiance'] > 0].copy()
    df_eff['efficiency'] = df_eff['total_power_kw'] / df_eff['irradiance']
    df_eff = df_eff[df_eff['efficiency'] <= 1000]
    fig6, ax6 = plt.subplots(figsize=(16, 6))
    sns.boxplot(x='cluster', y='efficiency', data=df_eff, palette='coolwarm', ax=ax6)
    ax6.set_title('Power Efficiency Ratio per Cluster (Power / Irradiance)')
    ax6.set_xlabel('Cluster')
    ax6.set_ylabel('Efficiency (kW per W/m¬≤)')
    ax6.tick_params(axis='x', rotation=45)
    ax6.grid(True)
    st.pyplot(fig6)
    

    # 7. Hourly Power by Cluster
    st.subheader("‚è±Ô∏è Hourly Power Variation per Cluster")
    st.markdown("_This plot shows how power output changes during the day by hour for each cluster._")
    df["timestamp"] = pd.to_datetime(df["timestamp"], format="%H:%M:%S")
    df["hour"] = df["timestamp"].dt.hour
    fig7, ax7 = plt.subplots(figsize=(16, 6))
    sns.boxplot(data=df, x='hour', y='total_power_kw', hue='cluster', palette='Spectral', ax=ax7)
    ax7.set_title('Hourly Power Variation per Cluster')
    ax7.set_xlabel('Hour of Day')
    ax7.set_ylabel('Total Power (kW)')
    ax7.grid(True)
    ax7.legend(title='Cluster', bbox_to_anchor=(1.05, 1), loc='upper left')
    st.pyplot(fig7)

    # -------------------- ML Prediction --------------------
    # --------- Power Prediction using RF ---------
    st.subheader("üîã Power Output Prediction using Random Forest")
    st.markdown("This section uses a trained Random Forest model to predict the expected power output based on irradiance and cluster.")

    try:
        rf_model = joblib.load("models/random_forest_model.pkl")
        df_rf = df[df["irradiance"] > 0].copy()
        df_rf["timestamp"] = df_rf["timestamp"].dt.time
        df_rf_encoded = pd.get_dummies(df_rf, columns=["cluster"], drop_first=True)
        feature_cols_rf = [col for col in df_rf_encoded.columns if col not in ["timestamp", "total_power_kw", "day"]]

        rf_preds = rf_model.predict(df_rf_encoded[feature_cols_rf])
        df_rf["Predicted_Power"] = rf_preds

        st.success("‚úÖ Random Forest Prediction completed.")
        st.dataframe(df_rf[["timestamp", "cluster", "irradiance", "Predicted_Power"]].head(700))

        st.markdown("_The table above shows predicted solar power output (in kW) based on irradiance and cluster using the Random Forest model._")

        # -------------------- Random Forest Model Evaluation --------------------
        st.subheader("üìâ Model Evaluation: Random Forest Prediction")

        st.markdown(
            "This section evaluates the accuracy of the **Random Forest** model in predicting solar power output. "
            "The scatter plot below compares the **actual vs. predicted** values. "
            "Points closer to the red dashed line indicate better prediction performance."
        )

        st.image("images/RF Evaluation.png", caption="Actual vs Predicted - Random Forest", use_container_width=True)

        st.markdown("### üìä Evaluation Metrics")
        st.write("**Mean Squared Error (MSE)**: `24,080.23`")
        st.write("**R¬≤ Score**: `0.9222`")

    except Exception as e:
        st.error(f"‚ùå Error during Random Forest prediction: {e}")

           # -------------------- XGBoost Performance Classification --------------------
    st.subheader("üìà Cluster Performance Classification using XGBoost")

    st.markdown(
        "This section uses a trained **XGBoost classifier** to predict whether each cluster is performing efficiently or not. "
        "The classification is based on an efficiency threshold calculated from the data."
    )

    try:
        # ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿßŸÑŸÖÿØÿ±ÿ®
        xgb_model = joblib.load("models/xgb_classifier_model.pkl")

        # ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        df_class = df[df["irradiance"] > 0].copy()
        df_class["efficiency"] = df_class["total_power_kw"] / df_class["irradiance"]

        # ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ° ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÖŸäÿØŸäÿßŸÜ
        threshold = df_class["efficiency"].median()
        df_class["performance_label"] = (df_class["efficiency"] > threshold).astype(int)

        # ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ≥ÿßÿπÿ©
        df_class["timestamp"] = pd.to_datetime(df_class["timestamp"], format="%H:%M:%S")
        df_class["hour"] = df_class["timestamp"].dt.hour

        # ÿ™ÿ±ŸÖŸäÿ≤ ÿßŸÑÿ£ÿπŸÖÿØÿ©
        df_class_encoded = pd.get_dummies(df_class, columns=["cluster"], drop_first=True)
        drop_cols = ["timestamp", "day", "total_power_kw", "irradiance", "efficiency", "performance_label"]
        X_perf = df_class_encoded.drop(columns=drop_cols)

        # ÿßŸÑÿ™ŸÜÿ®ÿ§
        performance_preds = xgb_model.predict(X_perf)
        df_class["Predicted_Performance"] = ["High" if p == 1 else "Low" for p in performance_preds]

        # ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
        df_display = df_class[["timestamp", "cluster", "efficiency", "Predicted_Performance"]].copy()
        df_display["timestamp"] = df_display["timestamp"].dt.strftime("%H:%M")

        st.success("‚úÖ XGBoost Performance Prediction completed.")
        st.dataframe(df_display.head(500))

        # -------------------- Evaluation Images --------------------
        st.markdown("### üß™ Model Evaluation")

        st.image("images/Confusion Matrix - XGBoost Classifier.png", caption="Confusion Matrix - XGBoost Classifier", width=500)
        st.markdown(
            "The confusion matrix shows how well the classifier distinguished between **High** and **Low** performing clusters. "
            "- A high number of correct predictions (top-left and bottom-right) indicates strong model performance."
        )

        st.image("images/ROC Curve - XGBoost Classifier.png", caption="ROC Curve - XGBoost Classifier", width=500)
        st.markdown(
            "The **ROC curve** evaluates the classifier's ability to separate classes. "
            "**AUC = 0.91** suggests excellent model performance in distinguishing between high and low efficiency clusters."
        )

    except Exception as e:
        st.error(f"‚ö†Ô∏è Error during performance prediction: {e}")

else:
    st.info("üì§ Please upload an Excel file to begin.")
